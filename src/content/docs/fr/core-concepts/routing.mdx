---
title: Routage
description: Une introduction √† l'utilisation du routage avec Astro.
---
import FileTree from '~/components/FileTree.astro'

Astro utilise un **routage bas√© sur les fichiers** pour g√©n√©rer les URLs de votre dossier de compilation en fonction des dossiers de votre projet `src/pages/`. Lorsqu'un fichier est ajout√© au dossier `src/pages/` de votre projet, une route avec le m√™me nom que ce fichier est alors disponible automatiquement.

## Routes Statiques

Les composants `.astro` et les fichiers Markdown (`.md`) dans le dossier `src/pages/` **deviennent des pages de votre site web**. Chaque composant (nomm√© _composant Page_) correspond √† son chemin et nom dans le dossier `src/pages/`.

```bash
# Exemple: Routes statiques
src/pages/index.astro        -> monsite.com/
src/pages/about.astro        -> monsite.com/about
src/pages/about/index.astro  -> monsite.com/about
src/pages/about/me.astro     -> monsite.com/about/me
src/pages/posts/1.md         -> monsite.com/posts/1
```

:::tip
Il n'y a pas de "configuration de routage" s√©par√©e √† maintenir dans un projet Astro ! Lorsque vous ajoutez un fichier dans le r√©pertoire `/src/pages`, une nouvelle route est automatiquement cr√©√©e pour vous. Dans les constructions statiques, vous pouvez personnaliser le format de sortie du fichier en utilisant l'option de configuration [`build.format`](/fr/reference/configuration-reference/#buildformat).
:::

## Navigation entre les pages

Astro utilise des [√©l√©ments HTML`<a>`](https://developer.mozilla.org/fr-FR/docs/Web/HTML/Element/a) standards pour naviguer entre les routes. Il n'y a pas de composant `<Link>` sp√©cifique au framework fourni.

```astro title="src/pages/index.astro"
<p>Lire d'avantage <a href="/about/">a propos</a> d'Astro!</p>
```

## Routes Dynamiques

Un fichier de page Astro peut sp√©cifier des param√®tres de route dynamiques dans son nom de fichier pour g√©n√©rer les pages correspondantes. Par exemple, vous pouvez cr√©er un fichier `authors/[author].astro` qui g√©n√®re une page de biographie pour chaque auteur de votre blog. `author` devient un _param√®tre_ accessible depuis l'int√©rieur de la page.

Dans le mode de sortie statique par d√©faut d'Astro, ces pages sont g√©n√©r√©es au moment de la construction, et vous devez donc pr√©d√©terminer la liste des `author` qui obtiennent un fichier correspondant. En mode SSR, une page sera g√©n√©r√©e sur demande pour toute route qui correspond.

### Mode Statique (SSG)

Parce que toutes les routes doivent √™tre d√©termin√©es au moment de la construction, une route dynamique doit exporter un `getStaticPaths()` qui renvoie un tableau d'objets avec une propri√©t√© `params`. Chacun de ces objets g√©n√©rera une route correspondante.

`[dog].astro` d√©finit le param√®tre dynamique `dog` dans son nom de fichier, donc les objets retourn√©s par `getStaticPaths()` doivent inclure `dog` dans leurs `params`. La page peut alors acc√©der √† ce param√®tre en utilisant `Astro.params`.

```astro title="src/pages/dogs/[dog].astro"
---
export function getStaticPaths() {
  return [
    {params: {dog: 'clifford'}},
    {params: {dog: 'rover'}},
    {params: {dog: 'spot'}},
  ];
}

const { dog } = Astro.params;
---
<div>Bon chien, {dog} !</div>
```

Cela va g√©n√©rer trois pages : `/dogs/clifford`, `/dogs/rover`, et `/dogs/spot`, chacune affichant le nom du chien correspondant.

Le nom du fichier peut inclure plusieurs param√®tres, qui doivent tous √™tre inclus dans les objets `params` de `getStaticPaths()` :

```astro title="src/pages/[lang]-[version]/info.astro"
---
export function getStaticPaths () {
 return [
    {params: {lang: 'en', version: 'v1'}},
    {params: {lang: 'fr', version: 'v2'}},
  ];
}

const { lang, version } = Astro.params;
---
...
```

Cela va g√©n√©rer `/en-v1/info` et `/fr-v2/info`.

Les param√®tres peuvent √™tre inclus dans des parties distinctes du chemin, ainsi nous pourrions utiliser `src/pages/[lang]/[version]/info.astro` avec le m√™me `getStaticPaths` pour g√©n√©rer `/en/v1/info` et `/fr/v2/info`.

üìö En savoir plus sur [`getStaticPaths()`](/fr/reference/api-reference/#getstaticpaths).

### Param√®tres REST

Si vous avez besoin de plus de flexibilit√© dans le routage de vos URL, vous pouvez utiliser un [param√®tre REST](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...path]`) dans votre nom de fichier `.astro` pour correspondre aux chemins de fichiers de n'importe quelle profondeur :

```astro title="src/pages/sequences/[...path].astro"
---
export function getStaticPaths() {
  return [
    {params: {path: 'one/two/three'}},
    {params: {path: 'four'}},
    {params: {path: undefined }}
  ]
}

const { path } = Astro.params;
---
...
```

Cela g√©n√©rera `/sequences/one/two/three`, `/sequences/four`, et `/sequences`. (Donner au param√®tre rest la valeur `undefined` lui permet de correspondre √† la page de niveau principal).

Les param√®tres rest peuvent √™tre utilis√©s avec **d'autres param√®tres nomm√©s**. Par exemple, nous pourrions repr√©senter le visualiseur de fichiers de GitHub avec une route dynamique comme celle-ci :


```
/[org]/[repo]/tree/[branch]/[...file]
```
Dans cet exemple, une requ√™te pour `/withastro/astro/tree/main/docs/public/favicon.svg` serait divis√©e en les param√®tres nomm√©s suivants :

```js
{
	org: 'withastro',
	repo: 'astro',
	branch: 'main',
	file: 'docs/public/favicon.svg'
}
```

#### Exemple : Pages dynamiques √† plusieurs niveaux

Ici, nous utilisons un param√®tre rest (`[...slug]`) et la fonctionnalit√© [`props`](/fr/reference/api-reference/#data-passing-with-props) de `getStaticPaths()` pour g√©n√©rer des pages pour des slugs de diff√©rentes profondeurs.

```astro title="src/pages/[...slug].astro"
---
export async function getStaticPaths() {
  const pages = [
    {
      slug: undefined,
      title: "Magasin Astro",
      text: "Bienvenue dans le magasin Astro!",
    },
    {
      slug: "products",
      title: "Produits Astro",
      text: "Nous avons beaucoup de produits pour vous",
    },
    {
      slug: "products/astro-handbook",
      title: "L'ultime manuel d'Astro",
      text: "Si vous voulez apprendre Astro, vous devez lire ce livre.",
    },
  ];
  return pages.map(({ slug, title, text }) => {
    return {
      params: { slug },
      props: { title, text },
    };
  });
}

const { title, text } = Astro.props;
---
<html>
  <head>
    <title>{title}</title>
  </head>
  <body>
    <h1>{title}</h1>
    <p>{text}</p>
  </body>
</html>
```

### Mode serveur (SSR)

En [mode SSR](/fr/guides/server-side-rendering/), les routes dynamiques sont d√©finies de la m√™me mani√®re : incluez des crochets `[param]` ou `[...path]` dans vos noms de fichiers pour faire correspondre des cha√Ænes ou des chemins arbitraires. Mais comme les routes ne sont plus construites √† l'avance, la page sera servie √† toute route correspondante. Puisque ce ne sont pas des routes "statiques", `getStaticPaths` ne devrait pas √™tre utilis√©.

```astro title="src/pages/resources/[resource]/[id].astro"
---
const { resource, id } = Astro.params;
---
<h1>{resource}: {id}</h1>
```

Cette page sera servie pour toute valeur de `resource` et `id` : `resources/users/1`, `resources/colors/blue`, etc.

#### Modification de l'exemple `[...slug]` pour le mode SSR

Comme les pages SSR ne peuvent pas utiliser `getStaticPaths`, elles ne peuvent pas recevoir de props. Ici, nous modifions notre [exemple pr√©c√©dent](#exemple--pages-dynamiques-√†-plusieurs-niveaux) pour qu'il fonctionne en SSR en recherchant la valeur du param√®tre `slug` dans un objet. Si la route est √† la racine ("/"), le param√®tre slug sera `undefined`. Si la valeur n'existe pas dans l'objet, nous redirigeons vers une page 404.


```astro title="src/pages/[...slug].astro"
---
const pages = [
	{
		slug: undefined,
		title: 'Magasin Astro',
		text: 'Bienvenue dans le magasin Astro !',
	},
	{
		slug: 'products',
		title: 'Produits Astro',
		text: 'Nous avons beaucoup de produits pour vous',
	},
	{
		slug: 'products/astro-handbook',
		title: "L'ultime manuel d'Astro",
		text: 'Si vous voulez apprendre Astro, vous devez lire ce livre.',
	}
];

const { slug } = Astro.params;
const page = pages.find((page) => page.slug === slug);
if (!page) return Astro.redirect("/404");
const { title, text } = page;
---
<html>
<head>
  <title>{title}</title>
</head>
<body>
  <h1>{title}</h1>
  <p>{text}</p>
</body>
</html>
```

## Ordre de Priorit√© des Routes

Il est possible que plusieurs routes correspondent au m√™me chemin URL. Par exemple, chacune de ces routes correspondrait √† `/posts/create` :

<FileTree>
- src/pages/
  - posts/
    - create.astro
    - [pid].astro
    - [...slug].astro
</FileTree>

Astro a besoin de savoir quelle route doit √™tre utilis√©e pour construire la page. Pour ce faire, il les trie en fonction des r√®gles suivantes :

- Les routes statiques sans param√®tres de chemin d'acc√®s ont la priorit√© sur toutes les autres routes.
- Les routes dynamiques utilisant des param√®tres nomm√©s sont prioritaires par rapport aux param√®tres rest.
- Les param√®tres de repos ont la priorit√© la plus basse
- Les √©galit√©s sont r√©solues par ordre alphab√©tique

√âtant donn√© l'exemple ci-dessus, voici quelques exemples de la fa√ßon dont les r√®gles vont faire correspondre une URL demand√©e √† la route utilis√©e pour construire le HTML :

- `pages/post/create.astro` - Correspondra au chemin `/post/create`
- `pages/post/[pid].astro` - Correspondra au chemin `/post/1`, `/post/abc`, etc. Mais pas √† `/post/create`
- `pages/post/[...slug].astro` - Correspondra au chemin `/post/1/2`, `/post/a/b/c`, etc. Mais pas √† `/post/create`, `/post/1`, `/post/abc`

## Pagination

Astro supporte la pagination pour les grandes collections de donn√©es qui doivent √™tre divis√©es en plusieurs pages. Astro va g√©n√©rer les propri√©t√©s les plus communes de pagination comme l'URL pour page pr√©c√©dente / suivante, le nombre total de pages, etc.

Les noms de routes pagin√©es doivent utiliser la m√™me syntaxe de `[crochets]` que les routes dynamiques. Par exemple, le nom de fichier `/astronauts/[page].astro` g√©n√©rera des routes pour `/astronauts/1`, `/astronauts/2`, etc, l√† o√π `[page]` est le num√©ro de pages g√©n√©r√©es.

Vous pouvez utiliser la fonction `paginate()` pour g√©n√©rer ces pages pour un tableau de valeurs comme suit :

```astro /{ (paginate) }/ /paginate\\(.*\\)/ /(?<=const.*)(page)/ /page\\.[a-zA-Z]+/
---
// Exemple: /src/pages/astronauts/[page].astro
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }, {
    astronaut: 'Jean-Loup Chr√©tien',
  }, {
    astronaut: 'Thomas Pesquet',
  }];
  // G√©n√®re des pages √† partir de notre tableau d'astronautes, avec 2 par page
  return paginate(astronautPages, { pageSize: 2 });
}
// Toutes les donn√©es pagin√©es sont pass√©es dans la propri√©t√© "page"
const { page } = Astro.props;
---
<!-- Affiche le num√©ro de la page actuelle. Astro.params.page peut aussi √™tre utilis√© ! -->
<h1>Page {page.currentPage}</h1>
<ul>
  <!-- Fait la liste de notre tableau d'astronautes -->
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
```

Ceci va g√©n√©rer les pages suivantes, avec deux √©l√©ments par page :

- `/astronauts/1` - Page 1: Affiche "Neil Armstrong" et "Buzz Aldrin"
- `/astronauts/2` - Page 2: Affiche "Sally Ride" et "John Glenn"
- `/astronauts/3` - Page 3: Affiche "Jean-Loup Chr√©tien" et "Thomas Pesquet"

### La Propri√©t√© `page`

Lorsque vous utilisez la fonction `paginate()`, chaque page transmet ses donn√©es via une propri√©t√© `page`. La propri√©t√© `page` a pas mal de propri√©t√©s utiles, mais voici les plus importantes :

- **`page.data`** - Tableau contenant portion de donn√©es de la page que vous avez pass√© dans la fonction `paginate()`
- **`page.url.next`** - Lien vers la page suivante dans la collection
- **`page.url.prev`** - Lien vers la page pr√©c√©dente dans la collection

```astro /(?<=const.*)(page)/ /page\\.[a-zA-Z]+(?:\\.(?:prev|next))?/
---
// Exemple: /src/pages/astronauts/[page].astro
// Paginons la m√™me liste d'objets { astronaut } que l'exemple pr√©c√©dent
export async function getStaticPaths({ paginate }) { /* ... */ }
const { page } = Astro.props;
---
<h1>Page {page.currentPage}</h1>
<ul>
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
{page.url.prev ? <a href={page.url.prev}>Pr√©c√©dent</a> : null}
{page.url.next ? <a href={page.url.next}>Suivant</a> : null}
```

#### R√©f√©rence Compl√®te de l'API

```ts
interface Page<T = any> {
	/** R√©sultat */
	data: T[];
	/** M√©tadonn√©es */
	/** Nombre du premier √©l√©ment de la page, √† partir de 0 */
	start: number;
	/** Nombre du dernier √©l√©ment de la page, √† partir de 0 */
	end: number;
	/** Nombre total de r√©sultats */
	total: number;
	/** Num√©ro de la page actuelle, √† partir de 1 */
	currentPage: number;
	/** Nombre d'√©l√©ments par page (par d√©faut : 25) */
	size: number;
	/** Nombre de la derni√®re page */
	lastPage: number;
	url: {
		/** URL de la page actuelle */
		current: string;
		/** URL de la page pr√©c√©dente (si il y en a une) */
		prev: string | undefined;
		/** URL de la page suivante (si il y en a une) */
		next: string | undefined;
	};
}
```

## Pagination Imbriqu√©e

Une utilisation plus avanc√©e pour la pagination est la **pagination imbriqu√©e**. Il s'agit du cas o√π la pagination est combin√©e avec d'autres param√®tres de route dynamique. Vous pouvez utiliser la pagination imbriqu√©e pour grouper votre collection pagin√©e par une propri√©t√© ou un tag.

Par exemple, si vous voulez grouper vos articles en Markdown par tag, vous pouvez utiliser la pagination imbriqu√©e en cr√©ant une page `/src/pages/[tag]/[page].astro` qui correspond aux URL suivantes :

- `/red/1` (tag=red)
- `/red/2` (tag=red)
- `/blue/1` (tag=blue)
- `/green/1` (tag=green)

La pagination imbriqu√©e fonctionne en retournant une collection de r√©sultats `paginate()` depuis `getStaticPaths()`, une pour chaque groupe.

Dans l'exemple suivant, nous allons impl√©menter la pagination imbriqu√©e pour construire les URL list√©es ci-dessus :

```astro /(?:[(]|=== )(tag)/ "params: { tag }" /const [{ ]*(page|params)/
---
// Exemple: /src/pages/[tag]/[page].astro
export function getStaticPaths({paginate}) {
  const allTags = ['red', 'blue', 'green'];
  const allPosts = await Astro.glob('../../posts/*.md');
  // Pour chaque tag, retourne un r√©sultat paginate().
  // Assurez-vous que vous passez "{params: {tag}}" √† la fonction "paginate()"
  // Assurez-vous qu'Astro conna√Æt les tags du r√©sultat
  return allTags.map((tag) => {
    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);
    return paginate(filteredPosts, {
      params: { tag },
      pageSize: 10
    });
  });
}
const { page } = Astro.props;
const params = Astro.params;
```

## Exclure des pages

Vous pouvez exclure des pages, ou m√™me des r√©pertoires entiers de la construction en pr√©fixant leurs noms avec un trait de soulignement (`_`).

Cela vous permet de cr√©er des pages priv√©es, et aussi de placer les tests, les utilitaires et les composants avec les pages qui leur sont associ√©es, en les emp√™chant d'√™tre construits en fichiers `.html` et plac√©s dans le r√©pertoire `dist/`.

Dans cet exemple, seuls `src/pages/index.astro` et `src/pages/posts/post1.md` seront construits comme routes de pages et fichiers HTML.

<FileTree>
- src/pages/
  - _r√©pertoire-cach√©/
    - page1.md
    - page2.md
  - _page-cach√©e.astro
  - **index.astro**
  - posts/
    - _SomeComponent.astro
    - _utils.js
    - **post1.md**
</FileTree>
