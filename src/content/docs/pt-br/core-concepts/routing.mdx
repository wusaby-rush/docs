---
title: Roteamento
description: Uma introdu√ß√£o a roteamento com Astro.
i18nReady: true
---
import FileTree from '~/components/FileTree.astro'


Astro utiliza **roteamento baseado em arquivos** para gerar as URLs da sua build com base no layout dos arquivos no diret√≥rio `src/pages` do seu projeto. Quando um arquivo √© adicionado ao diret√≥rio `src/pages` do seu projeto, ele √© automaticamente disponibilizado como uma rota baseada no seu nome de arquivo.

## Rotas est√°ticas

Componentes Astro (`.astro`) e arquivos Markdown (`.md`) no diret√≥rio `src/pages` **automaticamente se tornam p√°ginas no seu website**. A rota de cada p√°gina corresponde ao seu caminho e nome no diret√≥rio `src/pages`.

```diff 
# Exemplo: Rotas est√°ticas
src/pages/index.astro        -> meusite.com/
src/pages/sobre.astro        -> meusite.com/sobre
src/pages/sobre/index.astro  -> meusite.com/sobre
src/pages/sobre/mim.astro     -> meusite.com/sobre/mim
src/pages/postagens/1.md         -> meusite.com/postagens/1
```

:::tip
N√£o existe uma "configura√ß√£o de roteamento" separada para se manter em um projeto Astro! Quando voc√™ adiciona um arquivo no diret√≥rio `/src/pages/`, uma nova rota √© criada automaticamente para voc√™. Em builds est√°ticas, voc√™ pode customizar o formato de sa√≠da do arquivo utilizando a op√ß√£o [`build.format`](/pt-br/reference/configuration-reference/#buildformat) da configura√ß√£o. 
:::

## Navegando entre p√°ginas

Astro usa [elementos `<a>`](https://developer.mozilla.org/pt-BR/docs/Web/HTML/Element/a) padr√µes do HTML para navegar entre rotas. N√£o h√° um componente `<Link>` espec√≠fico do framework sendo providenciado.

```astro title="src/pages/index.astro"
<p>Leia mais <a href="/sobre/">sobre</a> Astro!</p>
```

## Rotas din√¢micas

Um arquivo de p√°gina Astro pode especificar par√¢metros de rota din√¢micos em seu nome de arquivo para gerar p√°ginas correspondentes. Por exemplo, voc√™ pode criar um arquivo `autores/[autor].astro` que gera uma p√°gina de biografia para cada autor no seu blog. `autor` se torna um _par√¢metro_ que voc√™ pode acessar de dentro da p√°gina.

No modo est√°tico padr√£o do Astro, essas p√°ginas s√£o geradas em tempo de build, e logo, voc√™ precisa predeterminar a lista de `autor`es que ganham um arquivo correspondente. No modo SSR, uma p√°gina ser√° gerada na requisi√ß√£o para qualquer rota que corresponde.

### Modo Est√°tico (SSG)

Por conta de todas as rotas precisarem ser determinadas em tempo de build, uma rota din√£mica precisa exportar um `getStaticPaths()` que retorna um array de objetos com uma propriedade `params`. Cada um desses objetos ir√° gerar uma rota correspondente.

`[cachorro].astro` define o par√¢metro din√¢mico `cachorro` em seu nome de arquivo, ent√£o os objetos retornados por `getStaticPaths()` devem incluir `cachorro` em suas `params`. A p√°gina pode ent√£o acessar esse par√¢metro utilizando `Astro.params`.

```astro title="src/pages/cachorros/[cachorro].astro"
---
export function getStaticPaths() {
  return [
    {params: {cachorro: 'clifford'}},
    {params: {cachorro: 'rover'}},
    {params: {cachorro: 'spot'}},
  ];
}

const { cachorro } = Astro.params;
---
<div>Bom garoto, {cachorro}!</div>
```

Isso ir√° gerar tr√™s p√°ginas: `/cachorros/clifford`, `/cachorros/rover`, and `/cachorros/spot`, cada uma mostrando o nome do cachorro correspondente.

O nome do arquivo pode incluir m√∫ltiplos par√¢metros, sendo que todos precisam ser inclusos nos objetos `params` em `getStaticPaths()`:

```astro title="src/pages/[lingua]-[versao]/info.astro"
---
export function getStaticPaths() {
 return [
    {params: {lingua: 'en', versao: 'v1'}},
    {params: {lingua: 'fr', versao: 'v2'}},
  ];
}
const { lingua, versao } = Astro.params;
---
...
```

Isso ir√° gerar `/en-v1/info` e `/fr-v2/info`.

Par√¢metros podem ser incluidos em partes separadas do caminho, ent√£o poder√≠amos utilizar `src/pages/[lingua]/[versao]/info.astro` com o mesmo `getStaticPaths` para gerar `/en/v1/info` e `/fr/v2/info`.

üìö Leia mais sobre [`getStaticPaths()`](/pt-br/reference/api-reference/#getstaticpaths).

#### Par√¢metros Rest

Se voc√™ precisa de mais flexibilidade no roteamento de sua URL, voc√™ pode utilizar um [par√¢metro rest](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...caminho]`) no nome do seu arquivo `.astro` para corresponder caminhos de arquivo de qualquer profundidade:

```astro title="src/pages/sequencias/[...caminho].astro"
---
export function getStaticPaths() {
  return [
    {params: {caminho: 'um/dois/tr√™s'}},
    {params: {caminho: 'quatro'}},
    {params: {caminho: undefined }}
  ]
}
const { caminho } = Astro.params;
---
...
```

Isso ir√° gerar `/sequencias/um/dois/tr√™s`, `/sequencias/quatro` e `/sequencias`. (Definir o par√¢metro rest como `undefined` o permite corresponder a p√°gina de n√≠vel superior.)

Par√¢metros rest podem ser utilizados com **outros par√¢metros nomeados**. Por exemplo, poder√≠amos representar o visualizador de arquivos do GitHub com uma rota din√¢mica assim:

```
/[org]/[repo]/tree/[branch]/[...arquivo]
```

Nesse exemplo, uma requisi√ß√£o a `/withastro/astro/tree/main/docs/public/favicon.svg` seria dividida nos seguintes par√¢metros nomeados:

```js
{
	org: 'withastro',
	repo: 'astro',
	branch: 'main',
	arquivo: 'docs/public/favicon.svg'
}
```

#### Exemplo: P√°ginas din√¢micas em m√∫ltiplos n√≠veis

Aqui, n√≥s utilizamos um par√¢metro (`[...slug]`) e a funcionalidade [`props`](/pt-br/reference/api-reference/#passagem-de-dados-com-props) de `getStaticPaths()` para gerar p√°ginas para slugs de diferentes profundidades.

```astro title="src/pages/[...slug].astro"
---
export async function getStaticPaths() {
  const paginas = [
    {
      slug: undefined,
      titulo: "Loja Astro",
      texto: "Bem-vindo √† loja Astro!",
    },
    {
      slug: "produtos",
      titulo: "Produtos Astro",
      texto: "N√≥s temos v√°rios produtos para voc√™",
    },
    {
      slug: "produtos/manual-astro",
      titulo: "O manual definitivo do Astro",
      texto: "Se voc√™ quer aprender Astro, voc√™ precisa ler esse livro.",
    },
  ];
  return paginas.map(({ slug, titulo, texto }) => {
    return {
      params: { slug },
      props: { titulo, texto },
    };
  });
}
const { titulo, texto } = Astro.props;
---
<html>
  <head>
    <title>{titulo}</title>
  </head>
  <body>
    <h1>{titulo}</h1>
    <p>{texto}</p>
  </body>
</html>
```

### Modo Servidor (SSR)

No [modo SSR](/pt-br/guides/server-side-rendering/), rotas din√¢micas s√£o definidas da mesma forma: inclua colchetes `[param]` ou `[...path]` no nome de seus sarquivos para corresponder a strings ou caminhos arbrit√°rios. Por√©m, j√° que as rotas n√£o s√£o mais contru√≠das com anteced√™ncia, a p√°gina ser√° servida para qualquer rota correspondente. J√° que essas n√£o s√£o rotas "est√°ticas", `getStaticPaths` n√£o deve ser utilizado.

```astro title="src/pages/recursos/[recurso]/[id].astro"
---
const { recurso, id } = Astro.params;
---
<h1>{recurso}: {id}</h1>
```
A p√°gina ser√° servida para qualquer valor de `recurso` e `id`: `recursos/usuarios/1`, `recursos/cores/azul`, etc.

#### Modificando o exemplo `[...slug]` para SSR

J√° que p√°ginas SSR n√£o podem utilizar `getStaticPaths`, elas n√£o podem receber props. Aqui, n√≥s modificamos nosso [exemplo anterior](#exemplo-p√°ginas-din√¢micas-em-m√∫ltiplos-n√≠veis) para funcionar com SSR ao olhar para o valor do par√¢metro `slug` em um objeto. Se a rota est√° na raiz ("/"), o par√¢metro slug ser√° `undefined`. Se o valor n√£o existe no objeto, n√≥s redirecionamos para uma p√°gina de 404.

```astro title="src/pages/[...slug].astro"
---
const paginas = [
  {
    slug: undefined,
    titulo: "Loja Astro",
    texto: "Bem-vindo √† loja Astro!",
  },
  {
    slug: "produtos",
    titulo: "Produtos Astro",
    texto: "N√≥s temos v√°rios produtos para voc√™",
  },
  {
    slug: "produtos/manual-astro",
    titulo: "O manual definitivo do Astro",
    texto: "Se voc√™ quer aprender Astro, voc√™ precisa ler esse livro.",
  },
];

const { slug } = Astro.params;
const pagina = paginas.find((pagina) => pagina.slug === slug);
if (!pagina) return Astro.redirect("/404");
const { titulo, texto } = pagina;
---
<html>
<head>
  <title>{titulo}</title>
</head>
<body>
  <h1>{titulo}</h1>
  <p>{texto}</p>
</body>
</html>
```

## Ordem de Prioridade de Rotas

√â poss√≠vel que m√∫ltiplas rotas correspondam ao mesmo caminho de URL. Por exemplo, cada uma destas rotas iria corresponder a `postagens/criar`:

<FileTree>
- src/pages/
  - postagens/
    - criar.astro
    - [pid].astro
    - [...slug].astro
</FileTree>

Astro precisa saber qual rota deve ser utilizada para construir a p√°gina. Para fazer isso, Astro as ordena de acordo com as seguintes regras:

- Rotas est√°ticas sem par√¢metros de caminho ter√£o preced√™ncia sobre todas as outras rotas
- Rotas din√¢micas utilizando par√¢metros nomeados ter√£o preced√™ncia sobre par√¢metros rest
- Par√¢metros rest ter√£o a menor prioridade
- Empates s√£o resolvidos alfabeticamente

Com base no exemplo acima, aqui est√£o alguns exemplos de como as regras ir√£o corresponder a URL requisitada para a rota utilizada para construir o HTML:

- `pages/postagens/criar.astro` - ir√° construir `/postagens/criar`
- `pages/postagens/[pid].astro` - ir√° construir `/postagens/1`, `/postagens/abc`, etc. Mas n√£o `/postagens/criar`
- `pages/postagens/[...slug].astro` - ir√£ construir `/postagens/1/2`, `/postagens/a/b/c`, etc. Mas n√£o `/postagens/criar`, `/postagens/1`, `/postagens/abc`

## Pagina√ß√£o

Astro suporta pagina√ß√£o de forma integrada para grandes cole√ß√µes de dados que precisam ser dividos em m√∫ltiplas p√°ginas. Astro ir√° gerar propriedades comuns de pagina√ß√£o, como URLs de anterior/pr√≥xima p√°gina, n√∫mero total de p√°ginas, e mais.

Nomes de rotas paginadas devem utilizar a mesma sintaxe em `[colchetes]` de rotas din√¢micas comuns. Por exemplo, o nome de arquivo `/astronautas/[pagina].astro` ir√° gerar rotas para `/astronautas/1`, `/astronautas/2`, etc, onde `[pagina]` √© o n√∫mero gerado da p√°gina.

Voc√™ pode utilizar a fun√ß√£o `paginate()` para gerar estas p√°ginas a partir um array de valores como abaixo:

```astro /{ (paginate) }/ /paginate\\(.*\\)/ /(?<=const.*)(page)/ /page\\.[a-zA-Z]+/
---
// Exemplo: src/pages/astronautas/[pagina].astro
export async function getStaticPaths({ paginate }) {
  const paginasAstronautas = [{
    astronauta: 'Neil Armstrong',
  }, {
    astronauta: 'Buzz Aldrin',
  }, {
    astronauta: 'Sally Ride',
  }, {
    astronauta: 'John Glenn',
  }];
  // Gera p√°ginas a partir de nosso array de astronautas, com 2 por p√°gina
  return paginate(paginasAstronautas, { pageSize: 2 });
}
// Todos os dados paginados s√£o passados para a prop "page".
const { page } = Astro.props;
---

<!--Mostra o n√∫mero da p√°gina atual. Astro.params.page tamb√©m pode ser utilizado!-->
<h1>P√°gina {page.currentPage}</h1>
<ul>
  <!--Lista o array de informa√ß√µes sobre astronautas-->
  {page.data.map(({ astronauta }) => <li>{astronauta}</li>)}
</ul>
```
Isso gera as seguintes p√°ginas, com 2 itens por p√°gina:
- `/astronautas/1` - P√°gina 1: Mostra "Neil Armstrong" e "Buzz Aldrin"
- `/astronautas/2` - P√°gina 2: Mostra "Sally Ride" e "John Glenn"

### A prop `page`

Quando voc√™ utiliza a fun√ß√£o `paginate()`, cada p√°gina na cole√ß√£o passar√° seus dados atrav√©s da prop `page`. A prop `page` tem diversas propriedades √∫teis, mas a mais importante √© `page.data`. Esse √© o array contendo os peda√ßos de dados da p√°gina que voc√™ passou para a fun√ß√£o `paginate()`.

Quando voc√™ utiliza a fun√ß√£o `paginate()`, cada p√°gina ter√° seus dados passados atrav√©s da prop `page`. A prop `page` tem diversas propriedades √∫teis, mas aqui est√£o as mais importantes:
- **page.data** - array contendo um peda√ßo dos dados da p√°gina que voc√™ passou para a fun√ß√£o `paginate()`
- **page.url.next** - link para a pr√≥xima p√°gina no conjunto
- **page.url.prev** - link para a p√°gina anterior no conjunto

```astro /(?<=const.*)(page)/ /page\\.[a-zA-Z]+(?:\\.(?:prev|next))?/
---
// Exemplo: src/pages/astronautas/[pagina].astro
// Faz a pagina√ß√£o da mesma lista de objetos de { astronauta } do exemplo anterior
export async function getStaticPaths({ paginate }) { /* ... */ }
const { page } = Astro.props;
---
<h1>P√°gina {page.currentPage}</h1>
<ul>
  {page.data.map(({ astronauta }) => <li>{astronauta}</li>)}
</ul>
{page.url.prev ? <a href={page.url.prev}>Anterior</a> : null}
{page.url.next ? <a href={page.url.next}>Pr√≥ximo</a> : null}
```


### Refer√™ncia completa da API

```ts
interface Page<T = any> {
	/** resultado */
	data: T[];
	/** metadados */
	/** A contagem do primeiro item na p√°gina, come√ßando por 0 */
	start: number;
	/** A contagem do √∫ltimo item na p√°gina, come√ßando por 0 */
	end: number;
	/** n√∫mero total de resultados */
	total: number;
	/** n√∫mero da p√°gina atual, come√ßando por 1 */
	currentPage: number;
	/** n√∫mero de itens por p√°gina (padr√£o: 25) */
	size: number;
	/** n√∫mero da √∫ltima p√°gina */
	lastPage: number;
	url: {
		/** url da p√°gina atual*/
		current: string;
		/** url da p√°gina anterior (se existir) */
		prev: string | undefined;
		/** url da pr√≥xima p√°gina (se existir) */
		next: string | undefined;
	};
}
```

### Pagina√ß√£o Aninhada

Um caso de uso mais avan√ßado para p√°gina √© a **pagina√ß√£o aninhada**. Isso √© quando a pagina√ß√£o √© combinada com outros par√¢metros din√¢micos de rota. Voc√™ pode usar pagina√ß√£o aninhada para agrupar suas cole√ß√µes paginadas por alguma propriedade ou etiqueta.

Por exemplo, se voc√™ quiser agrupar suas postagens em Markdown por alguma etiqueta, voc√™ pode usar a pagina√ß√£o aninhada criando uma p√°gina `/src/pages/[etiqueta]/[pagina].astro` que iria corresponder com as seguintes URLs:

- `/vermelho/1` (etiqueta=vermelho)
- `/vermelho/2` (etiqueta=vermelho)
- `/azul/1` (etiqueta=azul)
- `/verde/1` (etiqueta=verde)

Pagina√ß√£o aninhada funciona retornando um array de resultados do `paginate()` a partir do `getStaticPaths()`, sendo uma para cada agrupamento.

No exemplo abaixo, n√≥s iremos implementar a pagina√ß√£o aninhada para construir as URLs listados acima:

```astro /(?:[(]|=== )(etiqueta)/ "params: { etiqueta }" /const [{ ]*(page|params)/
---
// Exemplo: src/pages/[etiqueta]/[pagina].astro
export async function getStaticPaths({ paginate }) {
  const todasEtiquetas = ['vermelho', 'azul', 'verde'];
  const todasPostagens = await Astro.glob('../../postagens/*.md');
  // Para cada etiqueta, retorna um resultado de paginate().
  // Se certifique de que voc√™ passou `{params: {etiqueta}}` ao `paginate()`
  // para que o Astro saiba qual agrupamento de etiqueta o resultado √© para.
  return todasEtiquetas.map((etiqueta) => {
    const postagensFiltradas = todasPostagens.filter((postagem) => postagem.frontmatter.etiqueta === etiqueta);
    return paginate(postagensFiltradas, {
      params: { etiqueta },
      pageSize: 10
    });
  });
}
const { page } = Astro.props;
const params = Astro.params;
```

## Excluindo p√°ginas

Voc√™ pode excluir p√°ginas ou at√© mesmo diret√≥rios inteiros da build ao prefixar seus nomes com um subtra√ßo (`_`).

Isso permite que voc√™ crie p√°ginas privadas e tamb√©m co-localizar testes, utilit√°rios e componentes com suas p√°ginas relacionadas, as previnindo de serem construidas como arquivos `.html` e colocadas no diret√≥rio `dist/`.

Neste exemplo, apenas `src/pages/index.astro` e `src/pages/postagens/postagem1.md` ser√£o constru√≠das como rotas de p√°gina e arquivos HTML.

<FileTree>
- src/pages/
  - _diretorio-escondido/
    - pagina1.md
    - pagina2.md
  - _pagina-escondida.astro
  - **index.astro**
  - postagens/
    - _AlgumComponente.astro
    - _utils.js
    - **postagem1.md**
</FileTree>
